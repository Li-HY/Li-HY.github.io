{"meta":{"title":"BlogX","subtitle":"","description":"","author":"Hongyu Li","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Java习题","slug":"Java习题","date":"2021-04-14T14:46:35.000Z","updated":"2021-04-14T15:44:36.700Z","comments":true,"path":"2021/04/14/Java习题/","link":"","permalink":"http://example.com/2021/04/14/Java%E4%B9%A0%E9%A2%98/","excerpt":"","text":"输入流将数据从文件，标准输入或其他外部设备只能够加载到内存，在java中其对应于抽象类 java.io.InputStream及其子类 java.io.InputStream : 此抽象类是表示字节输入流的所有类的超类 java.io.OutputStream : 此抽象类是表示字节输出流的所有类的超类 main方法时Java Application程序执行入口点，合法的描述是： 1public static void main(String[] args) 如下程序段： 12345678910111213public class MyThead extends Thread&#123; public static void main(String[] args) &#123; MyThead t=new MyThead(); MyThead s=new MyThead(); t.start(); System.out.println(&quot;one.&quot;); s.start(); System.out.println(&quot;two.&quot;); &#125; public void run() &#123; System.out.println(&quot;Thread&quot;); &#125;&#125; start()是开启线程，等待获得时间片，一到获得时间片就执行。所以可能一开启就获得了时间片执行，也有可能等到two输出后才获得了时间片。 在java当中，线程通常有运行五种状态，创建、就绪、运行、阻塞和死亡 下列那些方法是线程安全的(所调用的方法都存在) 这几个类都没有类属性，不存在共享资源，为满足题目的意思，应是多线程情况喜爱使用同一个对i啊选哪个，以达到使成员共享资源的目的 123456public class MyServlet implements Servlet &#123;public void service (ServletRequest req, ServletResponse resp) &#123;BigInteger I = extractFromRequest(req);encodeIntoResponse(resp,factors);&#125;&#125; 此选项中，没有成员（没有共享资源），线程安全。 123456789101112public class MyServlet implements Servlet &#123;private long count =0;public long getCount() &#123;return count;&#125;public void service (ServletRequest req, ServletResponse resp) &#123;BigInteger I = extractFromRequest(req);BigInteger[] factors = factor(i);count ++;encodeIntoResponse(resp,factors);&#125;&#125; 此选项中，假设存在线程1和线程2，count初始值为0，当线程1执行count++中count+1（此时未写回最终计算值），这时线程2执行count++中读取count，发生数据错误，导致线程1线程2的结果都为1，而不是线程1的结果为1，线程2的结果为2，线程不安全； 123456789public class MyClass &#123;private int value;public synchronized int get() &#123;return value;&#125;public synchronized void set (int value) &#123;this.value = value;&#125;&#125; 此选项中成员私有，对成员的set get方法都加重量级锁，线程安全； 123456789101112public class Factorizer implements Servlet &#123;private volatile MyCache cache = new MyCache(null,null);public void service(ServletRequest req, ServletResponse resp) &#123;BigInteger i = extractFromRequest(req);BigInteger[] factors = cache.getFactors(i);if (factors == null) &#123;factors = factor(i);cache = new MyCache(i,factors);&#125;encodeIntoResponse(resp,factors);&#125; 此选项中链接：volatile有两个作用：可见性（volatile变量的改变能使其他线程立即可见，但它不是线程安全的，参考B）和禁止重排序；这里是可见性的应用，类中方法对volatile修饰的变量只有赋值，线程安全；","categories":[],"tags":[]},{"title":"","slug":"算法","date":"2021-04-08T13:46:36.000Z","updated":"2021-04-08T13:46:36.000Z","comments":true,"path":"2021/04/08/算法/","link":"","permalink":"http://example.com/2021/04/08/%E7%AE%97%E6%B3%95/","excerpt":"","text":"算法排序算法a.compareTo(b) a &gt; b,返回正数 a == b,返回0 a &lt; b,返回负数 选择排序插入排序希尔排序属于插入排序的一种，又称“缩小增量排序”，是插入排序算法的一种更高效的改进版本，能够交换更远的数据 排序原理： 1.选定一个增长量h，以增长量h作为数据分组的依据，对数据进行分组； 2.对分好组的每一组数据完成插入排序； 3.减小增长量，最小减为1，重复第二步的操作 举例： 9 1 2 5 7 4 8 6 3 5 初始 4 1 2 3 5 9 8 6 5 7 h=5进行第一趟排序：94、18、26、53、75进行比较，得到 2 1 4 3 5 6 5 7 8 9 h = 2进行第二趟排序，42585、13967进行比较，得到 1 2 3 4 5 5 6 7 8 9 h = 1进行第三趟排序，跟之前一样（但其实已经部分有序了） 增长量h的确定规则： 1234567int h = 1;while(h &lt; 数组的长度 / 2)&#123; h = 2 * h + 1;&#125;//循环结束之后可以确定h的最大值h 的减小规则为： h = h / 2 代码实现： 123456789101112131415161718192021222324public static void sort(Comparable[] a)&#123; int h = 1; while(h &lt; a.length / 2)&#123; h = 2 * h + 1; &#125; while(h &gt;= 1)&#123; //第一个待插入的元素为h for(int i = h;i &lt; a.length;i++)&#123; //找到待插入的元素插入到有序数组中 for(int j = i;j &gt;= h;j -= h)&#123; //待插入元素是a[j]，与a[j - h]进行比较 if(greater(a[j - h], a[j ]))&#123; //交换元素 exch(a,j - h,j); &#125;else&#123; //已经找到了元素的合适位置，结束循环 break; &#125; &#125; &#125; //减小h的值 h = h / 2; &#125; &#125; 实现： 12345public static void main(String[] args) &#123; Integer[] a = &#123;9,1,2,5,7,4,8,6,3,5&#125;; Shell.sort(a); System.out.println(Arrays.toString(a));&#125; 归并排序1递归​ 在定义方法时，方法内部调用方法本身，称之为递归。 ​ 注意：在递归中，必须要存在边界条件，能够让递归结束。 递归代码例： 123456789101112131415public class TestF &#123; public static void main(String[] args) &#123; //求n的阶乘 long res = fact(5); System.out.println(res); &#125; public static long fact(int n)&#123; //结束条件 if(n == 1)&#123; return 1; &#125; return n * fact(n-1); &#125;&#125; 2归并排序 1.尽可能的一组数据拆分成两个元素相等的数组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止； 2.将相邻的两个子组进行合并成一个有序的大组； 3.不断的重复步骤2，直到最终只有一个组为止。 Leetcode题解双指针（共7题）双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务 1234567891011graph LRA(双指针技巧套路框架)--&gt;B1(快慢指针常用算法)A--&gt;B2(左右指针常用算法)B1--&gt;C1(判定链表中是否有环)B1--&gt;C2(已知链表中有环,返回这个环的起始位置)B1--&gt;C3(寻找无环链表的中点)B1--&gt;C4(寻找单链表的倒数第k个元素)B2--&gt;D1(二分搜索)B2--&gt;D2(两数之和)B2--&gt;D3(反转数组)B2--&gt;D4(滑动窗口算法) 1.有序数组的TwoSum–左右指针 Two Sum II - Input array is sorted (Easy) 12Input: numbers&#x3D;&#123;2, 7, 11, 15&#125;, target&#x3D;9Output: index1&#x3D;1, index2&#x3D;2 在有序数组中找出两个数，使它们的和为target。 将sum和target间进行比较 sum == target，得到要求的结果 sum &gt; target ，移动较大的数，使得sum的整体值变小 sum &gt; target，移动较小的数， 使得sum整体值变大 123456789101112131415public int[] twoSum(int[] numbers, int target) &#123; if(numbers == null) return null; int i = 0,j = numbers.length - 1; while(i &lt; j)&#123; int sum = numbers[i] + numbers[j]; if(sum == target)&#123; return new int[]&#123;i + 1, j + 1&#125;; &#125;else if(sum &lt; target)&#123; i++; &#125;else&#123; j--; &#125; &#125; return null; &#125; 2.两数平方和–左右指针633.Sum of Square Numbers (Easy) 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 123Input: 5Output: TrueExplanation: 1 * 1 + 2 * 2 &#x3D; 5 本题需要判断一个非负整数是否为两个整数的平方和。 法1： 可以看成是在0~c的有序数组中寻找两个数，与167题类似，但是最大的区别是在于一个是和，一个是平方和 关键在于右指针的初始化，设右指针为j= (int)Math.sqrt(c)，左指针i为0 123456789101112131415public boolean judgeSquareSum(int c) &#123; if(c &lt; 0) return false; int i = 0,j = (int)Math.sqrt(c); while (i &lt; j)&#123; int powsum = i * i + j * j; if(powsum == c)&#123; return true; &#125;else if(powsum &gt; c)&#123; j--; &#125;else&#123; i++; &#125; &#125; return false; &#125; 法2：二分查找 首先枚举a，保证c - a^2 &gt;= 0,然后通过二分查找的方法找出是否存在b，满足b^2 = c - a^2。 二分查找的范围为[0, c - a^2] 1234567891011121314151617181920public class Solution &#123; public boolean judgeSquareSum(int c) &#123; for (long a = 0; a * a &lt;= c; a++) &#123; int b = c - (int)(a * a); if (binary_search(0, b, b)) return true; &#125; return false; &#125; public boolean binary_search(long s, long e, int n) &#123; if (s &gt; e) return false; long mid = s + (e - s) / 2; if (mid * mid == n) return true; if (mid * mid &gt; n) return binary_search(s, mid - 1, n); return binary_search(mid + 1, e, n); &#125;&#125; 法3：费马平方和定理 一个非负整数 c 能够表示为两个整数的平方和，当且仅当 c的所有形如 4k+3的质因子的幂次均为偶数。 对c进行质因数分解，在判断形如4k+3的质因子的幂次是否均为偶数 3.反转字符串中的元音字符–左右指针 Reverse Vowels of a String (Easy) 编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 1Given s &#x3D; &quot;leetcode&quot;, return &quot;leotcede&quot;. 列出所有的元音字母","categories":[],"tags":[]},{"title":"图床测试","slug":"图床测试","date":"2021-04-04T15:38:21.000Z","updated":"2021-04-04T15:39:43.360Z","comments":true,"path":"2021/04/04/图床测试/","link":"","permalink":"http://example.com/2021/04/04/%E5%9B%BE%E5%BA%8A%E6%B5%8B%E8%AF%95/","excerpt":"","text":"gitee图床测试","categories":[],"tags":[]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2021-04-04T07:33:52.000Z","updated":"2021-04-04T07:42:46.156Z","comments":true,"path":"2021/04/04/我的第一篇博客文章/","link":"","permalink":"http://example.com/2021/04/04/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"第一章内容 第二章内容 参考文献","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-04-04T07:28:34.803Z","updated":"2021-04-04T07:28:34.803Z","comments":true,"path":"2021/04/04/hello-world/","link":"","permalink":"http://example.com/2021/04/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}